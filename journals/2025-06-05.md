- ðŸ“˜ Bought the book [[Just Enough Software Architecture]] by [[George Fairbanks]].
  - ðŸ“ Platform [[Google Play Books]].
  - ðŸ“„ Exported a PDF version.
  - ðŸ§  Summary:
    - Focuses on balancing formal architecture with agile development.
    - Advocates a **risk-driven** approach to decide how much architecture is needed.
    - Bridges the gap between code-level concerns and high-level design.
    - Emphasizes *just enough* modeling to address architectural risks without overengineering.
 - ## Chapter 1: Introduction
    - Software has continued to grow in scale and intricacy, now being among the largest and most complex artifacts ever built.
    - The book discusses how to combat complexity and emerge victorious.
    - The evolution of [[Software engineering]] has helped manage this complexity:
      - Transitioning from assembly to higher-level languages.
      - The introduction of [[OOP]].
      - Software reuse through libraries and frameworks.
    - Today's developers are not necessarily more skilled than those of previous generations, but improved tools and strategies have enabled us to scale up system complexity.
    - [[Abstractions]] are a powerful tool for managing complexity.
    - Abstractions allow developers to group together many low-level details, significantly reducing [[cognitive load]].
  - ### Chapter 1.1: Armory
    - Our supply of weapons can roughly be divided into three categories: **partitioning**, **knowledge**, and **abstractions**.
      - **Partitioning** means dividing the whole into parts to reduce complexity. Smaller components can be worked on independently and later assembled to achieve full system functionality.
      - **Knowledge** comes from previous experienceâ€”often through reuse. It can be personal, but more often it involves accepting and building upon the insights of previous generations.
        - > â€œIf I have seen further, it is by standing on the shoulders of giants.â€  
        > â€”Isaac Newton
      - **Abstraction** is deliberately designed to combat complexity and scale. By hiding details, it allows us to reduce the problem to a manageable size.
    - There are no [[silver bullets]] ([[Brooks, 1995]]); instead, we fight complexity with a variety of tools, and it is the **combination** of these tools that leads to success.
    - A proper [[Software Architecture]] naturally incorporates partitioning, knowledge, and abstractions.
