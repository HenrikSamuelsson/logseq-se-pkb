- Reading in the book [[Just Enough Software Architecture]].
	- ### Section 1.2: Examples of Software Architecture
	  collapsed:: true
		- George Fairbanks says:
			- > "Roughly speaking, architecture is the macroscopic design of a software system."
		- By this he means that **software architecture** refers to the **high-level, big-picture structure** of a system — not the fine-grained details like individual lines of code or small classes.
		- The word **macroscopic** means large-scale, as opposed to microscopic meaning small-scale.
		- It can be "hard to see the forest for the trees", to see the architecture of a system we have to intentionally look for it.
		- ### Evolution of Architecture: Tech Support System for Hosted Email Servers
		  collapsed:: true
			- The architectural evolution of a tech support system is presented in three stages:
				- **Version 1: Local log files**
					- To troubleshoot the system, an engineer would remotely connect to the server and run a [[grep]] query on the local logs.
					- This approach worked reasonably well but required skilled engineers rather than less-qualified support technicians.
					- It also lacked scalability.
				- **Version 2: Central database**
					- Log data was automatically collected and moved to a central server.
					- This allowed support technicians to search logs more easily.
					- However, the central database experienced significant performance issues.
					- The server handling the database was frequently overloaded and suffered from failures.
				- **Version 3: Indexing cluster**
					- The performance bottleneck was addressed by distributing the workload across multiple machines using [[Hadoop Distributed File System]].
					- Support technicians accessed the system through a web-based interface, similar to a search engine.
					- Engineers could contribute by designing new types of queries, which were turned into jobs that the system could execute.
	- ### Section 1.3: Reflections
	  collapsed:: true
		- We saw in the previous section that **architecture is separate from functionality** — a system can have wildly different architectures and still provide the same functionality.
		- **[[Quality attributes]]**
			- The first two versions excelled in [[modifiability]] — it was quick to write a new [[grep]] expression or modify a [[SQL]] query.
			- The third version introduced **latency**, as a new query required code changes and scheduling a job across a distributed system.
			- However, the third system excelled in [[scalability]], as it distributed processing using multiple machines. The trade-off was **batched job execution**, which introduced wait times.
			- Quality attributes often **compete** with each other — it’s difficult to optimize for scalability, low latency, modifiability, etc., all at once. **Architectural decisions require wise trade-offs**.
		- **[[Conceptual model]]**
			- Anyone can reason about the systems presented, but a trained [[software architect]] has a head start due to prior experience.
			- This advantage stems from having a **conceptual model** — a mental framework for understanding and analyzing system architecture — already ingrained in the mind.
			- An expert architect will recognize architectural patterns and know their names, which greatly aids in communicating design decisions to others.
			- Familiarity with patterns also supports achieving desired [[quality attributes]], since certain architectural patterns are known to promote specific attributes (e.g., scalability, modifiability, reliability).
		- **[[Abstractions]] and [[Constraints]]**
			- Abstractions and constraints both help us reason about code more effectively and move faster in development.
			- **Abstractions** hide low-level details, reducing [[cognitive load]].
				- For example, to understand how a piece of information flows through the system, we can often focus on a high-level view of a few modules.
				- We don’t need to concern ourselves with details like [[CRC]]s or [[FIFO]] buffers.
			- **Constraints** improve reasoning by limiting what individual components can do.
				- For instance, prohibiting a component from modifying global variables makes the system’s behaviour easier to control and adapt.
		-
	- ### Section 1.4: Perspective Shift
	  collapsed:: true
		- > "GOTO Considered Harmful"  
		  > Edsger Dijkstra, 1968
		- In earlier days, it was common to use `goto` statements to jump around in the code — and few questioned this practice.
		- Over time, there was a shift in perspective toward [[structured programming]].
		- Today, most programmers naturally see extensive use of `goto` as bad design, but this wasn't the consensus in the past.
		- Every major change in thinking meets some resistance at first. However, opponents often come around and embrace the new approach over time.
		- A new architectural idea doesn't mean older approaches must be discarded. Different styles and ideas often coexist and remain useful.
		- It's important to stay open to new ideas and actively explore them to remain current and effective as a software developer.
	- ### Section 1.5: Architects Architecting Architectures
	  collapsed:: true
		- ### Section 1.6: Risk-driven Software Architecture
			- There are different development processes to choose from when starting a project:
				- [[Agile]] processes typically involve little or no up-front design work.
				- Other processes, like the [[V-model]] or [[Waterfall]], may require extensive up-front design — especially in regulated domains.
			- While different processes have led to successful projects, it’s still valuable to analyze which process best fits the specific context.
			- The goal is to do *just enough* up-front design and planning to support a successful implementation.
			- The book introduces the *[[risk-driven model]]* for software architecture as a way to guide how much design work is needed.
				- The core idea: **identify risks**, and focus architectural effort on mitigating those risks.
				- For example, if **scalability** is a major risk, then invest more in designing how to distribute the workload across resources.
			- In cases where the project is similar to something previously built, architectural work can be minimized by reusing proven designs.
			- The risk-driven model shares similarities with the [[Spiral model]] [[Boehm, 1988]], which also emphasizes addressing the highest risk items first.
			- The key difference is that the **risk-driven model is narrower in scope**, focusing only on architectural decisions.
		- Some people resist the idea of [[software architecture]], but it’s rarely because they oppose structured or elegant code.
		- More often, resistance stems from misconceptions — such as fears of added bureaucracy, the belief that architects are pompous, or even jealousy over the architect’s influence or pay.
		- It’s important to distinguish between the **architect** (person), **architecting** (process), and **architecture** (artifact):
			- **The job role: [[Architect]]**
				- An architect is someone with the formal role or title, though they may be more or less hands-on in development.
				- Their main responsibility is to contribute to the architecting process and guide the team toward a sound architecture.
				- Having an architect doesn’t mean others shouldn’t be involved — the best outcomes come from collaboration.
			- **The process: [[Architecting]]**
				- Architecting is the process of designing the system.
				- This can range from detailed upfront design to a more agile, incremental design throughout the project.
				- You cannot tell which process was followed just by looking at the resulting architecture.
			- **The artifact: [[Architecture]]**
				- Architecture is the end result — the structure of the software as implemented.
				- It includes both the code and any supporting documentation that helps maintain and evolve the system while avoiding costly rework.
	- ### Section 1.6: Risk-driven Software Architecture
		- There are different development processes to choose from when starting a project:
			- [[Agile]] processes typically involve little or no up-front design work.
			- Other processes, like the [[V-model]] or [[Waterfall]], may require extensive up-front design — especially in regulated domains.
		- While different processes have led to successful projects, it’s still valuable to analyze which process best fits the specific context.
		- The goal is to do *just enough* up-front design and planning to support a successful implementation.
		- The book introduces the *[[risk-driven model]]* for software architecture as a way to guide how much design work is needed.
			- The core idea: **identify risks**, and focus architectural effort on mitigating those risks.
			- For example, if **scalability** is a major risk, then invest more in designing how to distribute the workload across resources.
		- In cases where the project is similar to something previously built, architectural work can be minimized by reusing proven designs.
		- The risk-driven model shares similarities with the [[Spiral model]] [[Boehm, 1988]], which also emphasizes addressing the highest risk items first.
		- The key difference is that the **risk-driven model is narrower in scope**, focusing only on architectural decisions.