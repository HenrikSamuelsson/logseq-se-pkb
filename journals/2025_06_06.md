- Reading in the book [[Just Enough Software Architecture]].
	- ### Section 1.2: Examples of Software Architecture
		- George Fairbanks says:
			- > "Roughly speaking, architecture is the macroscopic design of a software system."
		- By this he means that **software architecture** refers to the **high-level, big-picture structure** of a system — not the fine-grained details like individual lines of code or small classes.
		- The word **macroscopic** means large-scale, as opposed to microscopic meaning small-scale.
		- It can be "hard to see the forest for the trees", to see the architecture of a system we have to intentionally look for it.
		- ### Evolution of Architecture: Tech Support System for Hosted Email Servers
		  collapsed:: true
			- The architectural evolution of a tech support system is presented in three stages:
				- **Version 1: Local log files**
					- To troubleshoot the system, an engineer would remotely connect to the server and run a [[grep]] query on the local logs.
					- This approach worked reasonably well but required skilled engineers rather than less-qualified support technicians.
					- It also lacked scalability.
				- **Version 2: Central database**
					- Log data was automatically collected and moved to a central server.
					- This allowed support technicians to search logs more easily.
					- However, the central database experienced significant performance issues.
					- The server handling the database was frequently overloaded and suffered from failures.
				- **Version 3: Indexing cluster**
					- The performance bottleneck was addressed by distributing the workload across multiple machines using [[Hadoop Distributed File System]].
					- Support technicians accessed the system through a web-based interface, similar to a search engine.
					- Engineers could contribute by designing new types of queries, which were turned into jobs that the system could execute.
	- ### Section 1.3: Reflections
		- We saw in the previous section that **architecture is separate from functionality** — a system can have wildly different architectures and still provide the same functionality.
		- **[[Quality attributes]]**
			- The first two versions excelled in [[modifiability]] — it was quick to write a new [[grep]] expression or modify a [[SQL]] query.
			- The third version introduced **latency**, as a new query required code changes and scheduling a job across a distributed system.
			- However, the third system excelled in [[scalability]], as it distributed processing using multiple machines. The trade-off was **batched job execution**, which introduced wait times.
			- Quality attributes often **compete** with each other — it’s difficult to optimize for scalability, low latency, modifiability, etc., all at once. **Architectural decisions require wise trade-offs**.
		- **[[Conceptual model]]**
			- Anyone can reason about the systems presented, but a trained [[software architect]] has a head start due to prior experience.
			- This advantage stems from having a **conceptual model** — a mental framework for understanding and analyzing system architecture — already ingrained in the mind.
			- An expert architect will recognize architectural patterns and know their names, which greatly aids in communicating design decisions to others.
			- Familiarity with patterns also supports achieving desired [[quality attributes]], since certain architectural patterns are known to promote specific attributes (e.g., scalability, modifiability, reliability).
		- **[[Abstractions]] and [[Constraints]]**
			- Abstractions and constraints both help us reason about code more effectively and move faster in development.
			- **Abstractions** hide low-level details, reducing [[cognitive load]].
				- For example, to understand how a piece of information flows through the system, we can often focus on a high-level view of a few modules.
				- We don’t need to concern ourselves with details like [[CRC]]s or [[FIFO]] buffers.
			- **Constraints** improve reasoning by limiting what individual components can do.
				- For instance, prohibiting a component from modifying global variables makes the system’s behaviour easier to control and adapt.
	-